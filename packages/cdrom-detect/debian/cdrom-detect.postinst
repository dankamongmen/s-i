#! /bin/sh

set -e
. /usr/share/debconf/confmodule
#set -x

log() {
	logger -t cdrom-detect "$@"
}

fail () {
	log "CDROM-detect failed; unmounting CD just to be sure"
	umount /cdrom 2>/dev/null || true
	exit 1
}

# Is a cdrom already mounted?  If so, assume it's the right one..
mount | grep -q 'on /cdrom' && exit 0
if [ -e /cdrom/.disk/info ] ; then
	CDNAME=`cat /cdrom/.disk/info`
	log "Detected CD '$CDNAME'"
	exit 0
fi

hw-detect cdrom-detect/detect_progress_title || true

log "Searching for Debian installation media..."

mkdir /cdrom 2>/dev/null || true

while true
do
	mounted=0

	devices="$(list-devices cd)"
	for device in $devices; do
		if mount -t iso9660 -o ro,exec $device /cdrom; then
			log "CD-ROM mount succeeded: device=$device"
			mounted=1
			db_set cdrom-detect/cdrom_device $device
			break
		else
			log "CD-ROM mount failed: device=$device"
		fi
	done

	if [ "$mounted" = "1" ]; then
		break
	fi

	# If a device was detected but the mount failed, ask for the CD.
	if [ -n "$devices" ]; then
		db_input critical cdrom-detect/retry || [ $? -eq 30 ]
		db_go
		db_get cdrom-detect/retry
		if [ "$RET" = "true" ]; then
			log "Unmounting CD just to be sure"
			umount /cdrom 2>/dev/null || true
			continue
		else
			fail
		fi
	fi
 
	# If no device was detected, perhaps a driver floppy is needed.
	if [ -e /usr/lib/debian-installer/retriever/floppy-retriever ]; then
		db_input critical cdrom-detect/load_floppy
		db_go
		db_get cdrom-detect/load_floppy
		if [ "$RET" = true ]; then
			anna floppy-retriever
			hw-detect cdrom-detect/detect_progress_title || true
			continue
		fi
	fi
    
	# Otherwise manual configuration may be needed
	db_input critical cdrom-detect/manual_config || [ $? -eq 30 ]
	db_go
	db_get cdrom-detect/manual_config

	modules=none
	for i in `ls -1 /lib/modules/*/kernel/drivers/cdrom/ | sed 's/\.ko$//' | sed 's/\.o$//'`; do
		modules="$modules, $i"
	done
    
	if [ "$RET" = "true" ]; then
		db_subst cdrom-detect/cdrom_module choices "$modules"
		db_input critical cdrom-detect/cdrom_module || [ $? -eq 30 ]
		db_go

		db_get cdrom-detect/cdrom_module
		module="$RET"

		db_input critical cdrom-detect/cdrom_device || [ $? -eq 30 ]
		db_go

		db_get cdrom-detect/cdrom_device
		device="$RET"

		if [ "$module" != "none" ]; then
			modprobe $module
		fi
		if mount -t iso9660 -o ro,exec $device /cdrom; then
			log "CD-ROM mount succeeded: device=$device"
			mounted=1
			break
		else
			log "CD-ROM mount failed: device=$device"
			fail
		fi
	else
		fail
	fi
done

if [ -e /cdrom/.disk/info ] ; then
	CDNAME=`cat /cdrom/.disk/info`
	log "Detected CD '$CDNAME'"
else
	log "The available CD is not a Debian CD!"
	db_input critical cdrom-detect/wrong-cd || [ $? -eq 30 ]
	db_go
	fail 
fi

# Get all the pool directories into the dentry cache, to cut down on seek
# times.
poolcount="$(set -- /cdrom/pool/*/*; echo $#)"
db_progress START 0 "$poolcount" cdrom-detect/scanning_progress_title
for pooldir in /cdrom/pool/*/*; do
	if [ -d "$pooldir" ]; then
		db_subst cdrom-detect/scanning_progress_step DIR "$pooldir"
		db_progress INFO cdrom-detect/scanning_progress_step
		log-output --pass-stdout -t cdrom-detect find "$pooldir/" >/dev/null || true
	fi
	db_progress STEP 1
done
db_progress STOP

# Set the suite and codename used by base-installer and base-config
# to the suite/codename that is on the CD. This assumes that there
# will be no more than one distribution on the CD, and that one of
# the testing, stable, or unstable links will point to it. Since the
# CDs currently have many links, parse the Release file to get the
# actual suite name to use.
for distlink in stable testing unstable ; do
	relfile=/cdrom/dists/$distlink/Release
	if [ -e $relfile ] ; then
		suite=$(sed -n 's/^Suite: *//p' $relfile)
		codename=$(sed -n 's/^Codename: *//p' $relfile)
		log "Detected CD with '$suite' ($codename) distribution"
		db_set cdrom/suite $suite
		db_set cdrom/codename $codename

		break
	fi
done

if [ -z "$suite" ] ; then
	log "Error reading Release file; unable to determine distribution"
	db_input critical cdrom-detect/no-release || [ $? -eq 30 ]
	db_go
	fail
fi

# Ask for eject to be installed into /target/, to be able to use it in
# the finish-install script.
apt-install eject || true

# Hey, we're done
db_subst cdrom-detect/success cdname "$CDNAME"
db_input low cdrom-detect/success || [ $? -eq 30 ]
db_go

anna-install apt-mirror-setup || true
if [ ! -e /cdrom/.disk/base_installable ]; then
	log "Base system not installable from CD, requesting choose-mirror"
	anna-install choose-mirror || true
else
	anna-install apt-cdrom-setup || true
fi

exit 0
