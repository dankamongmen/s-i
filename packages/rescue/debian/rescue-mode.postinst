#! /bin/sh -e

. /usr/share/debconf/confmodule

# Be nice to monolithic users.
db_get rescue/enable
[ "$RET" = true ] || exit 0

log () {
	logger -t rescue-mode "$@"
}

try_load_module () {
	log-output -t rescue modprobe "$1" || true
}

chroot_has () {
	PATH="$CHROOT_PATH" search-path "$1"
}

disconnect_run () {
	env -i PATH="$PATH" TERM="$TERM" HOME=/ "$@" \
		<&$OLD_STDIN >&$OLD_STDOUT 2>&$OLD_STDERR
}

chroot_run () {
	disconnect_run chroot /target "$@"
}

try_load_module ext2
try_load_module ext3
try_load_module jfs
try_load_module reiserfs
try_load_module xfs

# Linux root filesystems won't be on vfat, but this may be useful anyway ...
try_load_module vfat

# RAID support
try_load_module md
try_load_module raid0
try_load_module raid1
try_load_module raid5
log-output -t rescue mdrun || true

# LVM support
try_load_module dm-mod
try_load_module lvm-mod
log-output -t rescue pvscan || true
log-output -t rescue vgscan || true

db_capb backup

PARTITIONS="$(find /dev/discs -follow -name part\* | sort | tr '\n' , | \
	sed 's/,$//; s/,/, /g')"

if lvdisplay -c | cut -d: -f4 | grep 0 >/dev/null; then
	# Some unavailable logical volumes; activate them
	log-output -t rescue vgchange -a y || true
fi
LVMPARTS="$(lvdisplay -c | sed 's/^ *//' | cut -d: -f1 | sort | tr '\n' , | \
	sed 's/,$//; s/,/, /g')" || LVMPARTS=
if [ "$LVMPARTS" ]; then
	PARTITIONS="${PARTITIONS:+$PARTITIONS, }$LVMPARTS"
fi

if [ -z "$PARTITIONS" ]; then
	# TODO: need a sensible error here, or perhaps drop through to a
	# fallback shell?
	log "no partitions found!"
	exit 1
fi
log "partitions found: $PARTITIONS"
db_subst rescue/root PARTITIONS "$PARTITIONS"

while :; do
	db_input critical rescue/root
	db_go || exit 10
	db_get rescue/root
	rootdev="$RET"
	log "selected root device '$rootdev'"
	if [ ! -e "$rootdev" ]; then
		log "'$rootdev' does not exist"
		db_subst rescue/no-such-device DEVICE "$rootdev"
		db_input critical rescue/no-such-device
		# Since continuing returns to the rescue/root question,
		# backing up returns to the main menu.
		db_go || exit 10
		continue
	fi

	mkdir -p /target
	log-output -t rescue umount /target || true
	if ! log-output -t rescue mount "$rootdev" /target; then
		log "mount '$rootdev' /target failed"
		db_subst rescue/no-such-device DEVICE "$rootdev"
		db_input critical rescue/mount-failed
		# Since continuing returns to the rescue/root question,
		# backing up returns to the main menu.
		db_go || exit 10
		continue
	fi

	break
done

# Work out a sensible $PATH with respect to /target.
CHROOT_PATH=
OLD_IFS="$IFS"
IFS=:
for element in $PATH; do
	# Only include absolute elements.
	if [ "${element#/}" != "$element" ]; then
		CHROOT_PATH="${CHROOT_PATH:+$CHROOT_PATH:}/target$element"
	fi
done
IFS="$OLD_IFS"

OLD_STDIN="$DEBCONF_OLD_FD_BASE"
OLD_STDOUT="$(($DEBCONF_OLD_FD_BASE + 1))"
OLD_STDERR="$(($DEBCONF_OLD_FD_BASE + 2))"

FALLBACK_SHELL=

shell_failed () {
	FALLBACK_SHELL=rescue/maybe-fallback-shell
	db_subst "$FALLBACK_SHELL" SHELL "$*"
}

if [ -f /target/bin/sh ] && [ -x /target/bin/sh ]; then
	chroot_run /bin/sh -i || shell_failed '/bin/sh -i'
elif chroot_has sash; then
	chroot_run sash || shell_failed sash
	:
elif chroot_has busybox; then
	# Try this last even though busybox is useful, since it might fail
	# due to a missing sh applet.
	chroot_run busybox sh || shell_failed 'busybox sh'
else
	FALLBACK_SHELL=rescue/fallback-shell
fi

if [ "$FALLBACK_SHELL" ]; then
	db_subst "$FALLBACK_SHELL" DEVICE "$rootdev"
	db_input critical "$FALLBACK_SHELL"
	if ! db_go; then
		log-output -t rescue umount /target || true
		exit 10
	fi
	if [ "$FALLBACK_SHELL" != rescue/maybe-fallback-shell ] || \
	   (db_get "$FALLBACK_SHELL" && [ "$RET" = true ]); then
		# If this fails, we're doomed anyway!
		disconnect_run /bin/sh -i || true
	fi
fi

disconnect_run printf '\nRebooting...\n'

umount -a || true

/lib/debian-installer/exit
